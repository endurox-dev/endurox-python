#!/usr/bin/python3
##
## @brief Enduro/X Limited Python binary Linker
##  This linker does not support some of the pkgutil operations, such as
##  module listing in the package.
##
## @file expyld
##
## -----------------------------------------------------------------------------
## Python module for Enduro/X
##
## Copyright (C) 2021 - 2022, Mavimax, Ltd. All Rights Reserved.
## See LICENSE file for full text.
## -----------------------------------------------------------------------------
## AGPL license:
##
## This program is free software; you can redistribute it and/or modify it under
## the terms of the GNU Affero General Public License, version 3 as published
## by the Free Software Foundation;
##
## This program is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
## PARTICULAR PURPOSE. See the GNU Affero General Public License, version 3
## for more details.
##
## You should have received a copy of the GNU Affero General Public License along
## with this program; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
##
## -----------------------------------------------------------------------------
## A commercial use license is available from Mavimax, Ltd
## contact@mavimax.com
## -----------------------------------------------------------------------------

import argparse
from ast import Pass
from importlib.resources import path
import endurox as e
import os
from pathlib import Path
import importlib
import py_compile as c
import sys
import tempfile
#
# Single package entry
#
class PackageEntry(object):
	# Package name
	name=""

	# List of ModuleEntry in given package.
	# key is string (file/mod name w/o extension)
	# value is bytecode
	modules = {}

	# is this package?
	package = False

# list of main modules
M_main_code = None

#
# List of imported packages
#
M_packages = {}

# are -1, 0, 1 and 2.  A value of -1 means to use the optimization
# -ON
M_optimize = -1


def gen_module_code(c_file, prefix, module, code: bytes):
	""" Generate C byte array for embedding.
	Format to generate:

		const char ndrx_G_resource_opa[] = {
			0x0a, 0x0a, 0x64, 0x65, 0x66, 0x20, 0x79, 0x6f, 0x70, 0x74,
			0x28, 0x29, 0x3a, 0x0a, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x74,
			0x28, 0x22, 0x59, 0x4f, 0x22, 0x29, 0x0a, 0x0a, 0x00
			};
		const size_t ndrx_G_resource_opa_len = 28;
		#define ndrx_G_resource_opa_len_def 28	

	Naming convention:

	ndrxpy_G_<prefix>_<module_dots_to_underscore> -> array
	ndrxpy_G_<prefix>_<module_dots_to_underscore>_len -> size of the array
	ndrxpy_G_<prefix>_<module_dots_to_underscore>_def -> size of the array

	prefix -> "main" for the main
	prefix -> "pkg" for the packages

	Parameters
	----------
	c_file:file
		File handle open for write
	prefix:str
		Prefix for the table to generate (to separate main and package)
	module:str
		Module name with dots
	code:bytes
		Byte of the code to embed.

	Returns
	-------
	name:str
		Name of the table generated (that would be added to the the module index)

	"""

	c_mod = module.replace(".", "_")
	c_name = "ndrxpy_G_%s_%s" % (prefix, c_mod)

	# 
	c_file.write("const char %s[] = {\n" % c_name)

	counter=0
	first=True
	for b in code:

		if not first:
			c_file.write(", ")

			if counter % 10 == 0:
				c_file.write("\n")

		else:
			first=False

		c_file.write(f"0x{b:02x}")

		counter+=1

	# close the def
	c_file.write("\n};\n")

	# print the len handles
	c_file.write("const size_t ndrxpy_G_%s_%s_len = 28;\n" % (prefix, c_mod))
	c_file.write("#define ndrxpy_G_%s_%s_len_def 28\n\n" % (prefix, c_mod))
	table = "ndrxpy_G_%s_%s" % (prefix, c_mod) 

	e.tplog_debug("Generated table [%s]" % table)

	return table

#
# Generic module read
# See /usr/lib/python3.10/py_compile.py for compile procedure.
# This might a not be cross platform version.
#
def read_module(resource):
	"""Read module code to bytes()
	
	Parameters
	----------
	resource:str
		Name of the module/pkg to read

	"""

	res_notext, extension = os.path.splitext(resource)
	filename=os.path.basename(res_notext)
	path = os.path.realpath(os.path.dirname(resource))
	
	src = str(Path(path, filename))+".py"
	pyc = str(Path(path, filename))+".pyc"

	e.tplog_info("Loading mod filename: [%s] ext: [%s] path: [%s]"
		% (filename, extension, path))

	code=None
	if os.path.exists(src):
		# compile from source
		e.tplog_info("Compiling from source...")
		# based on /usr/lib/python3.10/py_compile.py
		loader = importlib.machinery.SourceFileLoader('<py_compile>', src)
		source_bytes = loader.get_data(src)

		try:
			code = loader.source_to_code(source_bytes, resource,
										_optimize=M_optimize)
		except Exception as err:
			py_exc = c.PyCompileError(err.__class__, err, resource)
			sys.stderr.write(py_exc.msg + '\n')
			raise err

		code = importlib._bootstrap_external._code_to_timestamp_pyc(code)
		code = bytes(code) 

	elif os.path.exists(pyc):
		in_file = open(pyc, "rb")
		code = in_file.read()
		in_file.close()
	else:
		file = importlib._bootstrap_external._get_cached(src)
		# load bytes
		e.tplog_info("Loading from cache [%s]" % file)

		in_file = open(file, "rb")
		code = in_file.read()
		in_file.close()

	e.tplogdump(5, "OK", code)

	return code

################################################################################
# Load main, sytnax supported:
# some_file.py
# ../some/path/to/some_file.py
# Firstly try to compile the script or if not found, then try to read from:
#   ./*.pyc in package folder
# 	./__pycache__/*.pyc (i.e. __pycache__/some_file.pyc or ../some/path/to/__pycache__/some_file.pyc)
#  and if that does not work, then load the sources & try to compile them.
################################################################################
def load_main(resource):
	global M_main_code
	M_main_code = read_module(resource)

################################################################################
# This accepts following module names to build
# function shall automatically discover:
# Do with:
# import importlib.util
# print(importlib.util.find_spec("requests").origin)
# if this resolves to ending with __init__.py, then it is package...
#  for pacakges we shall scan recursively while 
# if this resolves to ending with requests.py then it is module...
# The resource may be encoded in form of namespace.sub_module
# Also... Note that for linked packages importlib.util, 
# pkgutil.walk_packages will not work, as path is not set.
#
# When loading package we shall mark is this resource package or module
# due to fact, that this marking is required to find the sub-modules
# When loading sub-module, load all modules found in the way.
# When loading the module, check in the dict, if one is already loaded,
#  do no scan the current directory. However if recursive include is used
#  continue with sub-directory checking.
################################################################################
def load_module(resource, recursive):
	""" Load the package/module. If have *.py compile it, or if 

	Parameters
	----------
		resource: str
			module / package name to load
		recursive: bool
			If set to True, search for sub-folders for the package (had __init__.py)
			for sub-modules we do not require __init__.py, just main thing is that they contain
			py/pyc files.
	"""

	global M_packages

	e.tplog_info("Linking [%s] module" % (resource))

	spec = importlib.util.find_spec(resource)

	if spec is None:
		raise ModuleNotFoundError(ImportError(resource))

	filename = spec.origin
	path_real = os.path.dirname(filename)
	len_path_real = len(path_real)

	e.tplog_info("Linking [%s] module, path [%s]" % 
		(resource, path_real))

	prev_pkg = ""

	if os.path.basename(filename) == "__init__.py":

		#e.tplog_info(path_real)
		# This is package, lets scan it...
		
		for root, dir, files in os.walk(path_real):

			e.tplog_info("%s %s %s" % (str(root), str(dir), str(files)))
			# no cache please
			if "/__pycache__/" in root+"/":
				continue

			sub_pkg=""
			fin_pkg = ""
			tmp_root = root + "/"
			len_root = len(root)

			e.tplog_info(path_real+"/")

			#e.tplog_info("YOPT: tmp_root[%s] path_real[%s] len=%d" % (
			#	tmp_root, 	path_real+"/", len(root)
			#))

			if tmp_root.startswith(path_real+"/") and len(root)>len_path_real:
				sub_pkg = root[(len_path_real+1):].replace("/", ".")
				#e.tplog_info("YOPT %s %s" %sub_pkg)
				fin_pkg = resource+"."+sub_pkg
				
			else:
				fin_pkg = resource

			if fin_pkg not in M_packages:
				M_packages[fin_pkg]=PackageEntry()

			cur_pkg = M_packages[fin_pkg]
			cur_pkg.name = fin_pkg
			
			###############################################################
			# some.pkg.abc.ccc we need to get following keys:
			# some
			# some.pkg
			# some.pkg.abc
			# and marke these as packages. In case if such package
			# is missing we shall register it anyway, so that loader
			# can resolve them.
			###############################################################

			pkgs = cur_pkg.name.split(".")
			pkg_start = "";
			for p in pkgs:
				if len(pkg_start)>0:

					#
					# Mark previous pkg...
					#
					M_packages[pkg_start].package = True

					pkg_start=pkg_start+"."+p
				else:
					pkg_start=p


			# 
			# load module names *.py or *.pyc
			# 
			for f in files:
				res_notext, extension = os.path.splitext(f)
				e.tplog_info("Processing pkg [%s] mod [%s]" % (fin_pkg, res_notext))
				if (extension==".py" or extension==".pyc") and not res_notext in cur_pkg.modules:
					
					# Get the code object...
					e.tplog_debug("root[%s] vs [%s] f=[%s]" % (root, path_real, f))
					# Load the bytes
					cur_pkg.modules[res_notext] = read_module(str(Path(root, f)))			

			# scan the directories...
			if not recursive:
				break
	else:
		# This is single module
		pass

################################################################################
# Standard product banner
################################################################################
e.ndrx_sys_banner()

################################################################################
# CLOPT parsing.
################################################################################

parser = argparse.ArgumentParser(description='Enduro/X Python Linker')

parser.add_argument('-m', metavar='main_module', type=str, nargs='+',
		     		help='Main module to load as startup code')

parser.add_argument('-i', metavar='include', type=str, nargs='*',
                    help='Include package', action='append')

args = parser.parse_args()

################################################################################
# Prep the env.
################################################################################

cc = os.getenv("CC")
if cc is None:
	cc="cc"

# optional
clfags = os.getenv("CFLAGS")

# Load main -> module name + bytecodes
# args.infile compile...

e.tplog_info(str(args.i))

try:
	for source in args.m:
		load_main(source)

	if args.i is not None:
		for mod in args.i:
			for entry in mod:
				load_module(entry, True)
except SyntaxError:
	sys.exit(-1)

################################################################################
# Open the temporary file...
################################################################################

tmp = tempfile.NamedTemporaryFile(delete=False)
c_file = open(tmp.name, 'w')

#try:
e.tplog_debug("Temporary file open: %s" % tmp.name)

c_file.write("#include <stdlib.h>\n\n")

e.tplog_info("Generate main")
gen_module_code(c_file, "main", args.m[0], M_main_code)

e.tplog_info("Generate packages")
for p, pv in M_packages.items():
	for m, mv in pv.modules.items():
		gen_module_code(c_file, "pkg", m, mv)

# generate array ....
# generate index...
# generate loader / main...
# compile...

#finally:
#    tmp.close()
#    os.unlink(tmp.name)