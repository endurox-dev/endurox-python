#!/usr/bin/python3
##
## @brief Enduro/X Limited Python binary Linker
##  This linker does not support some of the pkgutil operations, such as
##  module listing in the package.
##
## @file expyld
##
## -----------------------------------------------------------------------------
## Python module for Enduro/X
##
## Copyright (C) 2021 - 2022, Mavimax, Ltd. All Rights Reserved.
## See LICENSE file for full text.
## -----------------------------------------------------------------------------
## AGPL license:
##
## This program is free software; you can redistribute it and/or modify it under
## the terms of the GNU Affero General Public License, version 3 as published
## by the Free Software Foundation;
##
## This program is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
## PARTICULAR PURPOSE. See the GNU Affero General Public License, version 3
## for more details.
##
## You should have received a copy of the GNU Affero General Public License along
## with this program; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
##
## -----------------------------------------------------------------------------
## A commercial use license is available from Mavimax, Ltd
## contact@mavimax.com
## -----------------------------------------------------------------------------

import argparse
from ast import Pass
from importlib.resources import path
import endurox as e
import os
from pathlib import Path
import importlib
import py_compile as c
import sys
import tempfile
#
# Single package entry
#
class PackageEntry(object):
	# Package name
	name=""

	# List of ModuleEntry in given package.
	# key is string (file/mod name w/o extension)
	# value is bytecode
	modules = {}

	# is this package?
	package = False

# list of main modules
M_main_code = None

# PackageEntry of the main modules
# key here is module name
M_main_mods = {}

#
# Key is full module name
# value is "table_ref".
# afterwards this is being sorted
# and c tables are generated
#
M_main_mods_flat = {}

#
# List of imported packages
#
M_packages = {}

#
# See M_main_mods_flat
#
M_packages_flat = {}

# are -1, 0, 1 and 2.  A value of -1 means to use the optimization
# -ON
M_optimize = -1

#
# Counter using for numbering all package intems, to have unique name
#
M_lnk_counter = 0;

def gen_index_search(c_file):
	"""Gen resoruce search func 
	
	Parameters
	----------
	c_file: file
		C temp output file
	
	"""

	# This shall generate some caches too. Save & return last result for given
	# table. As this might be used find_module() / load_module() in the sequence of calls.
	# also slots shall be used for mainmods & pkg index tables.

	c_file.write(
r"""
/**
 * Search the module
 * @param index package index table
 * @param index_len index length (number of rows)
 * @param module module name to search in the index
 * @param data if return is TRUE, then code bytes
 * @param dlen if return is TRUE, then code bytes length 
 * @return See NDRXPY_RES_
 */
static int ndrxpy_get_mod(ndrxpy_module_indext_t *index, int index_len, 
	char *module, char **data, ssize_t *dlen)
{
    /* perform binary search for class data */
	int ret = NDRXPY_RES_NOMOD;
    int first = 0;
    int last = index_len - 1;
    int middle = (first+last)/2;

    while (first <= last) 
    {
        /* -1 mod < module */
        /* 0 mod == module */
        /* 1 mod > module */
        int res = strcmp(index[middle].mod, module);

        if (res < 0)
        {
            first = middle + 1;    
        }
        else if (res==0) 
        {
            break;
        }
        else
        {
            last = middle - 1;
        }

        middle = (first + last)/2;
    }

    if (first > last)
    {
		/* not found */
        goto out;
    }


	*data = index[middle].data;
	*dlen = index[middle].len;
	ret=NDRXPY_RES_MOD_FOUND;

out:	
    return ret;
}

/**
 * Resolve python module
 * @param module module name to search for
 * @param data output object data
 * @param dlen object data len
 * @param NDRXPY_NOMOD/NDRXPY_PKG_FOUND/NDRXPY_MOD_FOUND
 */
static int ndrxpy_resolve(char *module, char **data, ssize_t *dlen)
{
	int ret = NDRXPY_RES_NOMOD;
	char tmpmod[PATH_MAX*2]="";
	/* Maybe needs this to be dynamic? */
	static __thread char cache_module[PATH_MAX*2]="";
	static __thread char *cache_data=NULL;
	static __thread ssize_t cache_dlen=0;
	static __thread int cache_ret=NDRXPY_RES_NOMOD;

#define DO_CACHE(MOD)	memcpy(cache_module, MOD); cache_data=*data; cache_dlen=*dlen; cache_ret=ret;
	/*
	 * Steps:
	 * - Search for module direct in both table, if found, ok return bytes.
	 * - If stuff is not found, try to add __init__ and search, only in second table.
	 * Provide result as: then return NDRXPY_MOD_FOUND(1), NDRXPY_PKG_FOUND(2), NDRXPY_NOMOD 0
	 */
	if (0==strcmp(module, cache_module))
	{
		*data=cache_data;
		*dlen = cache_dlen;
		ret=cache_ret;
		goto out;
	}

	/* Search main-module first */
	ret=ndrxpy_get_mod(G_ndrxpy_mainmods_index, 
		(sizeof(G_ndrxpy_mainmods_index)/sizeof(*(G_ndrxpy_mainmods_index))), 
		module, data, dlen);

	if (ret>NDRXPY_RES_NOMOD)
	{
		/* module found... */
		DO_CACHE(module);
		goto out;
	}

	/* Search pkg */
	ret=ndrxpy_get_mod(G_ndrxpy_pkg_index, 
		(sizeof(G_ndrxpy_pkg_index)/sizeof(*(G_ndrxpy_pkg_index))), 
		module, data, dlen);

	if (ret>NDRXPY_RES_NOMOD)
	{
		/* module found... */
		DO_CACHE(module);
		goto out;
	}

	/* If still not found, try __init__ and mark result as pkg */
	snprintf(tmpmod, sizeof(tmpmod), "%s.__init__", module);

	ret=ndrxpy_get_mod(G_ndrxpy_pkg_index, 
		(sizeof(G_ndrxpy_pkg_index)/sizeof(*(G_ndrxpy_pkg_index))), 
		tmpmod, data, dlen);

	if (ret>NDRXPY_RES_NOMOD)
	{
		/* mark as package found */
		ret=NDRXPY_RES_PKG_FOUND;
		DO_CACHE(tmpmod);
		goto out;
	}

out:
	return ret;
}

""")


def gen_index(c_file, index_name:str, flat_mods:dict):
	""" Generate binary search index table.
	Parameters
	----------
	c_file:
		Output temporary file
	index_name:str
		Name of the table index to generate
	flat_mods:dict
		Loaded index table to generate	
	"""
	# sort & plot...
	c_file.write(
"""
static ndrxpy_module_indext_t G_ndrxpy_%s_index [] =
{
""" % (index_name))

	first=True
	for k, v in sorted(flat_mods.items()):
		if not first:
			c_file.write(", \n")
		c_file.write('\t{"%s", %s, %s_len}' % (k,v,v)
			)
		first=False

	c_file.write("\n};")

def gen_first(c_file):
	"""Generate first things to the temp file"""

    # have some index struct.
	c_file.write(
"""struct ndrxpy_module_index
{
	const char *mod;	/**< Module name 					*/
	const char *data;	/**< bytes compiled 				*/
	size_t len;			/**< bytes compiled lenght  		*/
};

typedef struct ndrxpy_module_index ndrxpy_module_indext_t;


#define NDRXPY_RES_NOMOD 		0 /**< Module is not found 		*/
#define NDRXPY_RES_MOD_FOUND	1 /**< Module is found			*/
#define NDRXPY_RES_PKG_FOUND	2 /**< Package is found			*/

""")

def gen_module_code(c_file, prefix, module, code: bytes):
	""" Generate C byte array for embedding.
	Format to generate:

		const char ndrx_G_resource_opa[] = {
			0x0a, 0x0a, 0x64, 0x65, 0x66, 0x20, 0x79, 0x6f, 0x70, 0x74,
			0x28, 0x29, 0x3a, 0x0a, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x74,
			0x28, 0x22, 0x59, 0x4f, 0x22, 0x29, 0x0a, 0x0a, 0x00
			};
		const size_t ndrx_G_resource_opa_len = 28;
		#define ndrx_G_resource_opa_len_def 28	

	Naming convention:

	ndrxpy_G_<prefix>_<module_dots_to_underscore> -> array
	ndrxpy_G_<prefix>_<module_dots_to_underscore>_len -> size of the array
	ndrxpy_G_<prefix>_<module_dots_to_underscore>_def -> size of the array

	prefix -> "main" for the main
	prefix -> "pkg" for the packages

	Parameters
	----------
	c_file:file
		File handle open for write
	prefix:str
		Prefix for the table to generate (to separate main and package)
	module:str
		Module name with dots
	code:bytes
		Byte of the code to embed.

	Returns
	-------
	name:str
		Name of the table generated (that would be added to the the module index)

	"""

	global M_lnk_counter
	c_mod = module.replace(".", "_")
	c_name = "ndrxpy_G_%s_%s_%d" % (prefix, c_mod, M_lnk_counter)

	# 
	c_file.write("const char %s[] = {\n" % c_name)

	counter=0
	first=True
	for b in code:

		if not first:
			c_file.write(", ")

			if counter % 10 == 0:
				c_file.write("\n")

		else:
			first=False

		c_file.write(f"0x{b:02x}")

		counter+=1

	# close the def
	c_file.write("\n};\n")

	b_len = len(code)
	# print the len handles
	c_file.write("const size_t %s_len = %d;\n" % (c_name, b_len))
	c_file.write("#define %s_len_def %d\n\n" % (c_name, b_len))

	e.tplog_debug("Generated table [%s]" % c_name)
	M_lnk_counter+=1

	return c_name

#
# Generic module read
# See /usr/lib/python3.10/py_compile.py for compile procedure.
# This might a not be cross platform version.
#
def read_module(resource):
	"""Read module code to bytes()
	
	Parameters
	----------
	resource:str
		Name of the module/pkg to read

	"""

	res_notext, extension = os.path.splitext(resource)
	filename=os.path.basename(res_notext)
	path = os.path.realpath(os.path.dirname(resource))
	
	src = str(Path(path, filename))+".py"
	pyc = str(Path(path, filename))+".pyc"

	e.tplog_info("Loading mod filename: [%s] ext: [%s] path: [%s]"
		% (filename, extension, path))

	code=None
	if os.path.exists(src):
		# compile from source
		e.tplog_info("Compiling from source...")
		# based on /usr/lib/python3.10/py_compile.py
		loader = importlib.machinery.SourceFileLoader('<py_compile>', src)
		source_bytes = loader.get_data(src)

		try:
			code = loader.source_to_code(source_bytes, resource,
										_optimize=M_optimize)
		except Exception as err:
			py_exc = c.PyCompileError(err.__class__, err, resource)
			sys.stderr.write(py_exc.msg + '\n')
			raise err

		code = importlib._bootstrap_external._code_to_timestamp_pyc(code)
		code = bytes(code) 

	elif os.path.exists(pyc):
		in_file = open(pyc, "rb")
		code = in_file.read()
		in_file.close()
	else:
		file = importlib._bootstrap_external._get_cached(src)
		# load bytes
		e.tplog_info("Loading from cache [%s]" % file)

		in_file = open(file, "rb")
		code = in_file.read()
		in_file.close()

	e.tplogdump(5, "OK", code)

	return code


def load_main_dir(resource):
	"""Load main directory contents to separate index
	This is required due to fact if loading any module, then program's directory
	is scanned first for the module names and only then normal packages are loaded"""

	global M_main_mods
	path = os.path.realpath(os.path.dirname(resource))
	e.tplog_info("Loading program directroy [%s]" % resource)

	for f in os.listdir(path):

		if not os.path.isfile(f):
			continue

		res_notext, extension = os.path.splitext(f)
		e.tplog_info("Processing main directory, mod [%s]" % (res_notext))
		if (extension==".py" or extension==".pyc"):
			# Get the code object...
			e.tplog_debug("Reading module root[%s] f=[%s]" % (path, f))
			# Load the bytes
			M_main_mods[res_notext] = read_module(str(Path(path, f)))


################################################################################
# Load main, sytnax supported:
# some_file.py
# ../some/path/to/some_file.py
# Firstly try to compile the script or if not found, then try to read from:
#   ./*.pyc in package folder
# 	./__pycache__/*.pyc (i.e. __pycache__/some_file.pyc or ../some/path/to/__pycache__/some_file.pyc)
#  and if that does not work, then load the sources & try to compile them.
################################################################################
def load_main(resource):
	global M_main_code
	M_main_code = read_module(resource)
	load_main_dir(resource)

################################################################################
# This accepts following module names to build
# function shall automatically discover:
# Do with:
# import importlib.util
# print(importlib.util.find_spec("requests").origin)
# if this resolves to ending with __init__.py, then it is package...
#  for pacakges we shall scan recursively while 
# if this resolves to ending with requests.py then it is module...
# The resource may be encoded in form of namespace.sub_module
# Also... Note that for linked packages importlib.util, 
# pkgutil.walk_packages will not work, as path is not set.
#
# When loading package we shall mark is this resource package or module
# due to fact, that this marking is required to find the sub-modules
# When loading sub-module, load all modules found in the way.
# When loading the module, check in the dict, if one is already loaded,
#  do no scan the current directory. However if recursive include is used
#  continue with sub-directory checking.
################################################################################
def load_module(resource, recursive):
	""" Load the package/module. If have *.py compile it, or if 

	Parameters
	----------
		resource: str
			module / package name to load
		recursive: bool
			If set to True, search for sub-folders for the package (had __init__.py)
			for sub-modules we do not require __init__.py, just main thing is that they contain
			py/pyc files.
	"""

	global M_packages

	e.tplog_info("Linking [%s] module" % (resource))

	spec = importlib.util.find_spec(resource)

	if spec is None:
		raise ModuleNotFoundError(ImportError(resource))

	filename = spec.origin
	path_real = os.path.dirname(filename)
	len_path_real = len(path_real)

	e.tplog_info("Linking [%s] module, path [%s]" % 
		(resource, path_real))

	prev_pkg = ""

	if os.path.basename(filename) == "__init__.py":

		#e.tplog_info(path_real)
		# This is package, lets scan it...
		
		for root, dir, files in os.walk(path_real):
			e.tplog_info("%s %s %s" % (str(root), str(dir), str(files)))

			if "/__pycache__/" in root+"/":
				continue

			sub_pkg=""
			fin_pkg = ""
			tmp_root = root + "/"
			len_root = len(root)

			e.tplog_info(path_real+"/")

			#e.tplog_info("YOPT: tmp_root[%s] path_real[%s] len=%d" % (
			#	tmp_root, 	path_real+"/", len(root)
			#))

			# Resolve pckages & sub-packages
			if tmp_root.startswith(path_real+"/") and len(root)>len_path_real:
				sub_pkg = root[(len_path_real+1):].replace("/", ".")
				fin_pkg = resource+"."+sub_pkg
				#e.tplog_info("YOPT FIN_PKG [%s]" %fin_pkg)
			else:
				fin_pkg = resource

			if fin_pkg not in M_packages:
				M_packages[fin_pkg]=PackageEntry()

			cur_pkg = M_packages[fin_pkg]
			cur_pkg.name = fin_pkg
			
			###############################################################
			# some.pkg.abc.ccc we need to get following keys:
			# some
			# some.pkg
			# some.pkg.abc
			# and marke these as packages. In case if such package
			# is missing we shall register it anyway, so that loader
			# can resolve them.
			###############################################################

			pkgs = cur_pkg.name.split(".")
			pkg_start = "";
			for p in pkgs:
				if len(pkg_start)>0:

					#
					# Mark previous pkg...
					#
					M_packages[pkg_start].package = True

					pkg_start=pkg_start+"."+p
				else:
					pkg_start=p


			# 
			# load module names *.py or *.pyc
			# 
			for f in files:
				res_notext, extension = os.path.splitext(f)
				e.tplog_info("Processing pkg [%s] mod [%s]" % (fin_pkg, res_notext))
				if (extension==".py" or extension==".pyc") and not res_notext in cur_pkg.modules:
					# Get the code object...
					e.tplog_debug("root[%s] vs [%s] f=[%s]" % (root, path_real, f))
					# Load the bytes
					cur_pkg.modules[res_notext] = read_module(str(Path(root, f)))

			# scan the directories...
			if not recursive:
				break
	else:
		# This is single module
		pass

################################################################################
# Standard product banner
################################################################################
e.ndrx_sys_banner()

################################################################################
# CLOPT parsing.
################################################################################

parser = argparse.ArgumentParser(description='Enduro/X Python Linker')

parser.add_argument('-m', metavar='main_module', type=str, nargs='+',
		     		help='Main module to load as startup code')

parser.add_argument('-i', metavar='include', type=str, nargs='*',
                    help='Include package', action='append')

args = parser.parse_args()

################################################################################
# Prep the env.
################################################################################

cc = os.getenv("CC")
if cc is None:
	cc="cc"

# optional
clfags = os.getenv("CFLAGS")

# Load main -> module name + bytecodes
# args.infile compile...

e.tplog_info(str(args.i))

try:
	for source in args.m:
		load_main(source)

	if args.i is not None:
		for mod in args.i:
			for entry in mod:
				load_module(entry, True)
except SyntaxError:
	sys.exit(-1)

################################################################################
# Open the temporary file...
################################################################################

tmp = tempfile.NamedTemporaryFile(delete=False, suffix='.c')
c_file = open(tmp.name, 'w')

e.tplog_debug("Temporary file open: %s" % tmp.name)

c_file.write("#include <stdlib.h>\n\n")
c_file.write("#include <string.h>\n\n")

gen_first(c_file)
e.tplog_info("Generate main")
gen_module_code(c_file, "main", args.m[0], M_main_code)

e.tplog_info("Generate main mods")
for m, mv in M_main_mods.items():
	# index the modules
	M_main_mods_flat[m] = gen_module_code(c_file, "mmod", m, mv)

e.tplog_info("Generate packages")
for p, pv in M_packages.items():
	for m, mv in pv.modules.items():
		# index the modules
		M_packages_flat[p+"."+m] = gen_module_code(c_file, "pkg_"+p, m, mv)
	
# generate sorted index...
gen_index(c_file, "mainmods", M_main_mods_flat)
gen_index(c_file, "pkg", M_packages_flat)
gen_index_search(c_file)
# generate loader / main...
# compile...

#finally:
#    tmp.close()
#    os.unlink(tmp.name)
